{"_id": "e275dfd4409042ec", "name": "DBAE – Cast Spell (WP + Roll)", "type": "script", "img": "icons/svg/dice-target.svg", "command": "// Dragonbane Arcane Expansion: Cast Spell helper\n// Select a token, then run. It will prompt for one of the actor's spell items.\n// It will: (1) deduct WP if it can find a WP field, (2) roll damage/heal if the spell has a formula,\n// (3) post a chat card. If HP/WP paths differ in your Dragonbane system version, it will warn you.\n\nfunction getFirstPath(obj, paths) {\n  for (const p of paths) {\n    const parts = p.split(\".\");\n    let cur = obj;\n    let ok = true;\n    for (const part of parts) {\n      if (cur && Object.prototype.hasOwnProperty.call(cur, part)) cur = cur[part];\n      else { ok = false; break; }\n    }\n    if (ok) return p;\n  }\n  return null;\n}\n\nfunction getAtPath(obj, path) {\n  const parts = path.split(\".\");\n  return parts.reduce((o,k)=> (o? o[k]: undefined), obj);\n}\n\nasync function setAtPath(doc, path, value) {\n  const update = {};\n  update[path] = value;\n  return doc.update(update);\n}\n\nconst token = canvas?.tokens?.controlled?.[0];\nif (!token) return ui.notifications.warn(\"Select a token first.\");\nconst actor = token.actor;\nif (!actor) return ui.notifications.warn(\"No actor found on selected token.\");\n\nconst spells = actor.items.filter(i => i.type === \"spell\" || i.getFlag(\"dragonbane-arcane-expansion\",\"wp_cost\") !== undefined);\nif (!spells.length) return ui.notifications.warn(\"No spell items found on this actor.\");\n\nconst options = spells.map(s => `<option value=\"${s.id}\">${s.name}</option>`).join(\"\");\nconst dlg = await new Promise(resolve => {\n  new Dialog({\n    title: \"Cast Spell\",\n    content: `<form><div class=\"form-group\"><label>Spell</label><select id=\"spell\">${options}</select></div></form>`,\n    buttons: {\n      cast: { label: \"Cast\", callback: html => resolve(html.find(\"#spell\").val()) },\n      cancel: { label: \"Cancel\", callback: () => resolve(null) }\n    },\n    default: \"cast\"\n  }).render(true);\n});\nif (!dlg) return;\n\nconst item = actor.items.get(dlg);\nconst flags = item.getFlag(\"dragonbane-arcane-expansion\",\"\") || {};\nconst wpCost = Number(flags.wp_cost ?? flags.wp ?? 0) || 0;\nconst rollInfo = flags.roll ?? null;\n\n// Try to find WP field\nconst wpPath = getFirstPath(actor.system, [\n  \"willPoints.value\",\"willPoints.base\",\"willPoints.max\",\"wp.value\",\"wp.current\",\"willpower.value\",\"willpower.current\",\"resources.wp.value\",\"resources.wp.current\"\n]);\n\nlet wpBefore = null, wpAfter = null, wpOk = false;\nif (wpPath) {\n  wpBefore = getAtPath(actor.system, wpPath);\n  if (typeof wpBefore === \"number\") {\n    wpAfter = Math.max(0, wpBefore - wpCost);\n    await setAtPath(actor, \"system.\"+wpPath, wpAfter);\n    wpOk = true;\n  }\n}\n\nlet rollResult = null;\nif (rollInfo?.formula) {\n  const r = await (new Roll(rollInfo.formula)).roll({async:true});\n  rollResult = r;\n}\n\nconst school = item.system?.school ?? flags.school ?? \"\";\nconst tier = flags.tier ?? \"\";\nconst dtype = rollInfo?.damageType ?? \"\";\nconst rtype = rollInfo?.type ?? \"\";\n\nlet msg = `<h2>${item.name}</h2>`;\nmsg += `<p><strong>School:</strong> ${school || \"—\"} ${tier? `&nbsp; <strong>Tier:</strong> ${tier}`:\"\"}</p>`;\nmsg += `<p><strong>WP Cost:</strong> ${wpCost} ${wpOk? `(WP: ${wpBefore} → ${wpAfter})`:\"(WP not auto-deducted; check actor sheet WP field)\"}</p>`;\n\nif (rollResult) {\n  msg += `<p><strong>${rtype === \"healing\" ? \"Healing\" : \"Damage\"} Roll:</strong> ${rollInfo.formula} ${dtype? `(${dtype})`:\"\"}</p>`;\n  msg += await rollResult.render();\n}\n\nmsg += `<hr/>${item.system?.description?.value ?? \"\"}`;\n\nChatMessage.create({\n  speaker: ChatMessage.getSpeaker({actor}),\n  content: msg\n});", "ownership": {"default": 0}}
{"_id": "ff2fc90ec6ba400b", "name": "DBAE – Use Item (WP)", "type": "script", "img": "icons/svg/hand.svg", "command": "// Dragonbane Arcane Expansion: Use Item helper (WP-consuming artifacts)\nconst token = canvas?.tokens?.controlled?.[0];\nif (!token) return ui.notifications.warn(\"Select a token first.\");\nconst actor = token.actor;\nif (!actor) return ui.notifications.warn(\"No actor found on selected token.\");\n\nconst usable = actor.items.filter(i => [\"item\",\"weapon\",\"armor\",\"helmet\"].includes(i.type));\nif (!usable.length) return ui.notifications.warn(\"No usable items found on this actor.\");\n\nconst options = usable.map(s => `<option value=\"${s.id}\">${s.name}</option>`).join(\"\");\nconst itemId = await new Promise(resolve => {\n  new Dialog({\n    title: \"Use Item\",\n    content: `<form><div class=\"form-group\"><label>Item</label><select id=\"item\">${options}</select></div></form>`,\n    buttons: {\n      use: { label: \"Use\", callback: html => resolve(html.find(\"#item\").val()) },\n      cancel: { label: \"Cancel\", callback: () => resolve(null) }\n    },\n    default: \"use\"\n  }).render(true);\n});\nif (!itemId) return;\n\nconst item = actor.items.get(itemId);\nconst wpCost = Number(item.getFlag(\"dragonbane-arcane-expansion\",\"wp_cost\") ?? item.getFlag(\"dragonbane-arcane-expansion\",\"wpCost\") ?? 0) || 0;\n\nconst wpPath = \"system.willPoints.value\";\nconst wpBefore = foundry.utils.getProperty(actor, wpPath);\nlet wpAfter = wpBefore;\nif (typeof wpBefore === \"number\" && wpCost > 0) {\n  wpAfter = Math.max(0, wpBefore - wpCost);\n  await actor.update({[wpPath]: wpAfter});\n}\n\nlet msg = `<h2>${item.name}</h2>`;\nmsg += `<p><strong>WP Cost:</strong> ${wpCost} ${wpCost>0? `(WP: ${wpBefore} → ${wpAfter})`:\"\"}</p>`;\nmsg += `<hr/>${item.system?.itemDescription ?? \"\"}`;\n\nChatMessage.create({\n  speaker: ChatMessage.getSpeaker({actor}),\n  content: msg\n});", "ownership": {"default": 0}}
{"_id": "93810510a23d4832", "name": "DBAE – Use Sense Magic Ring", "type": "script", "img": "icons/svg/mystery-man.svg", "command": "// Use Sense Magic Ring: deduct 1 WP then cast Sense Magic if present on actor.\nconst token = canvas?.tokens?.controlled?.[0];\nif (!token) return ui.notifications.warn(\"Select a token first.\");\nconst actor = token.actor;\nconst wpPath = \"system.willPoints.value\";\nconst wp = foundry.utils.getProperty(actor, wpPath);\nif (typeof wp === \"number\") {\n  if (wp < 1) return ui.notifications.warn(\"Not enough WP.\");\n  await actor.update({[wpPath]: wp - 1});\n}\nconst spell = actor.items.find(i => i.type === \"spell\" && i.name.toLowerCase().includes(\"sense magic\"));\nif (!spell) return ui.notifications.warn(\"Actor does not have a Sense Magic spell item.\");\n// roll using Dragonbane system damage field if any\nconst dmg = spell.system?.damage;\nlet rollHtml = \"\";\nif (dmg) {\n  const r = await (new Roll(dmg)).roll({async:true});\n  rollHtml = await r.render();\n}\nChatMessage.create({\n  speaker: ChatMessage.getSpeaker({actor}),\n  content: `<h2>${spell.name}</h2><p><strong>WP Spent:</strong> 1</p>${rollHtml}<hr/>${spell.system?.itemDescription ?? \"\"}`\n});", "ownership": {"default": 0}}
{"_id": "21c6e14019ba473a", "name": "DBAE – Import to Expanded Dragonbane Folders", "type": "script", "img": "icons/svg/folder.svg", "command": "/**\n * DBAE – Import to Expanded Dragonbane Folders\n * Creates world folder structure (Items Directory) and imports spells/items from DBAE compendiums.\n * Folder layout (Dragonbane conventions):\n *\n * Expanded Dragonbane\n *  - Spells\n *    - Animism / Elementalism / Mentalism / Necromancy / Chronomancy / Voidmage / General\n *  - Items\n *    - Weapons / Armor / Helmets / Artifacts / Items\n *\n * Spells are sorted by Rank then Name within each school folder. Names are not modified.\n */\nconst ROOT = \"Expanded Dragonbane\";\n\nconst PACK_LABEL_SPELLS = \"Dragonbane – Spells\";\nconst PACK_LABEL_CANTRIPS = \"Dragonbane – Cantrips\";\nconst PACK_LABEL_ITEMS = \"Dragonbane – Items & Artifacts\";\n\nconst SCHOOLS = [\"Animism\",\"Elementalism\",\"Mentalism\",\"Necromancy\",\"Chronomancy\",\"Voidmage\",\"General\"];\n\nconst SCHOOL_MAP = new Map([\n  [\"DoD.spell.general\",\"General\"],\n  [\"General\",\"General\"],\n  [\"Animism\",\"Animism\"],\n  [\"Elementalism\",\"Elementalism\"],\n  [\"Mentalism\",\"Mentalism\"],\n  [\"Necromancy\",\"Necromancy\"],\n  [\"Chronomancy\",\"Chronomancy\"],\n  [\"Chronomage\",\"Chronomancy\"],\n  [\"Voidmage\",\"Voidmage\"],\n  [\"Void\",\"Voidmage\"]\n]);\n\nfunction normSchool(s) {\n  if (!s) return \"General\";\n  const raw = String(s).trim();\n  return SCHOOL_MAP.get(raw) ?? raw;\n}\n\nasync function ensureFolder(name, parentId = null) {\n  const existing = game.folders.find(f =>\n    f.type === \"Item\" &&\n    f.name === name &&\n    ((f.folder?.id ?? null) === parentId)\n  );\n  if (existing) return existing;\n  return Folder.create({ name, type: \"Item\", folder: parentId });\n}\n\nfunction findPack(labelFragment) {\n  return game.packs.find(p =>\n    p.documentName === \"Item\" &&\n    String(p.metadata?.label ?? p.title ?? \"\").includes(labelFragment)\n  ) ?? null;\n}\n\nfunction existingNamesInFolder(folderId) {\n  return new Set(game.items.filter(i => i.folder?.id === folderId).map(i => i.name));\n}\n\nfunction classifyItem(doc) {\n  const t = doc.type;\n  if (t === \"weapon\") return \"Weapons\";\n  if (t === \"armor\") return \"Armor\";\n  if (t === \"helmet\") return \"Helmets\";\n  // Dragonbane has no artifact type: heuristic by flags/name\n  const n = (doc.name ?? \"\").toLowerCase();\n  const wp = Number(doc.getFlag?.(\"dragonbane-arcane-expansion\",\"wp_cost\") ?? 0) || 0;\n  if (wp > 0 || n.includes(\"artifact\") || n.includes(\"grimoire\") || n.includes(\"relic\")) return \"Artifacts\";\n  return \"Items\";\n}\n\nasync function sortSpellsInFolder(folderId) {\n  const spells = game.items.filter(i => i.type === \"spell\" && i.folder?.id === folderId).slice();\n  spells.sort((a,b) => {\n    const ra = Number(a.system?.rank ?? 0) || 0;\n    const rb = Number(b.system?.rank ?? 0) || 0;\n    if (ra !== rb) return ra - rb;\n    return a.name.localeCompare(b.name);\n  });\n  const updates = spells.map((s, idx) => ({ _id: s.id, sort: (idx+1)*10 }));\n  if (updates.length) await Item.updateDocuments(updates);\n}\n\nasync function importPack(pack, filterFn, folderFn, postSortFn=null) {\n  if (!pack) return {created:0, skipped:0};\n  const index = await pack.getIndex({fields:[\"name\",\"type\"]});\n  const ids = index.filter(filterFn).map(e => e._id);\n\n  let created=0, skipped=0;\n  const touched = new Set();\n\n  for (const id of ids) {\n    const doc = await pack.getDocument(id);\n    const folder = folderFn(doc);\n    const names = existingNamesInFolder(folder.id);\n    if (names.has(doc.name)) { skipped++; continue; }\n\n    const data = doc.toObject();\n    delete data._id;\n    data.folder = folder.id;\n    const r = Number(data.system?.rank ?? 0) || 0;\n    data.sort = data.type === \"spell\" ? (r*10000 + created + 1) : ((created+1)*10);\n\n    await Item.create(data, {renderSheet:false});\n    created++;\n    touched.add(folder.id);\n  }\n\n  if (postSortFn) for (const fid of touched) await postSortFn(fid);\n  return {created, skipped};\n}\n\n(async () => {\n  if (!game.user.isGM) return ui.notifications.error(\"GM only.\");\n\n  // Folders\n  const root = await ensureFolder(ROOT);\n  const spellsRoot = await ensureFolder(\"Spells\", root.id);\n  const itemsRoot  = await ensureFolder(\"Items\",  root.id);\n\n  const schoolFolders = new Map();\n  for (const s of SCHOOLS) schoolFolders.set(s, await ensureFolder(s, spellsRoot.id));\n\n  const itemFolders = {\n    Weapons: await ensureFolder(\"Weapons\", itemsRoot.id),\n    Armor: await ensureFolder(\"Armor\", itemsRoot.id),\n    Helmets: await ensureFolder(\"Helmets\", itemsRoot.id),\n    Artifacts: await ensureFolder(\"Artifacts\", itemsRoot.id),\n    Items: await ensureFolder(\"Items\", itemsRoot.id)\n  };\n\n  // Packs\n  const spellsPack = findPack(PACK_LABEL_SPELLS);\n  const cantripsPack = findPack(PACK_LABEL_CANTRIPS);\n  const itemsPack = findPack(PACK_LABEL_ITEMS);\n\n  if (!spellsPack && !cantripsPack && !itemsPack) {\n    return ui.notifications.error(\"Could not find DBAE compendium packs. Check the label fragments in this macro.\");\n  }\n\n  const spellsRes = await importPack(\n    spellsPack,\n    e => e.type === \"spell\",\n    doc => {\n      const school = normSchool(doc.system?.school);\n      return schoolFolders.get(school) ?? schoolFolders.get(\"General\") ?? spellsRoot;\n    },\n    sortSpellsInFolder\n  );\n\n  const cantripsRes = await importPack(\n    cantripsPack,\n    e => e.type === \"spell\",\n    doc => {\n      const school = normSchool(doc.system?.school);\n      return schoolFolders.get(school) ?? schoolFolders.get(\"General\") ?? spellsRoot;\n    },\n    sortSpellsInFolder\n  );\n\n  const itemsRes = await importPack(\n    itemsPack,\n    e => e.type !== \"spell\",\n    doc => {\n      const bucket = classifyItem(doc);\n      return itemFolders[bucket] ?? itemFolders.Items;\n    }\n  );\n\n  ui.notifications.info(\n    `DBAE import complete.\\n` +\n    `Spells: +${spellsRes.created} (skipped ${spellsRes.skipped})\\n` +\n    `Cantrips: +${cantripsRes.created} (skipped ${cantripsRes.skipped})\\n` +\n    `Items: +${itemsRes.created} (skipped ${itemsRes.skipped})`\n  );\n})();", "ownership": {"default": 0}}
{"_id": "ff1bfd73c2f8419d", "name": "DBAE – Cleanup Imported DBAE Content", "type": "script", "img": "icons/svg/trash.svg", "command": "/**\n * DBAE – Cleanup Imported DBAE Content\n * Deletes WORLD copies of Items (incl. spells) and Journals that were imported from DBAE compendiums.\n * Uses flags.core.sourceId (best signal). Does NOT delete compendiums.\n */\nconst MODULE_ID = \"dragonbane-arcane-expansion\";\nconst PACKS = [\"spells\",\"cantrips\",\"items\",\"journals\",\"macros\"];\n\nfunction isFromDBAE(doc) {\n  const sid = doc.getFlag?.(\"core\",\"sourceId\");\n  if (!sid) return false;\n  const s = String(sid);\n  // Match any of this module's packs\n  return PACKS.some(p => s.includes(`Compendium.${MODULE_ID}.${p}.`));\n}\n\n(async () => {\n  if (!game.user.isGM) return ui.notifications.error(\"GM only.\");\n\n  const items = game.items.filter(i => isFromDBAE(i));\n  const journals = game.journal.filter(j => isFromDBAE(j));\n\n  const total = items.length + journals.length;\n  if (!total) return ui.notifications.info(\"No imported DBAE world content found (by sourceId).\");\n\n  const html = `\n    <p>This will delete <strong>${items.length}</strong> Items (including spells) and <strong>${journals.length}</strong> Journal Entries from the WORLD.</p>\n    <p><em>Compendiums are not affected.</em></p>\n    <details><summary>Preview (first 30)</summary>\n      <ul>\n        ${items.slice(0,30).map(i => `<li>[Item] ${i.name}</li>`).join(\"\")}\n        ${journals.slice(0,30).map(j => `<li>[Journal] ${j.name}</li>`).join(\"\")}\n      </ul>\n    </details>\n  `;\n\n  new Dialog({\n    title: \"DBAE Cleanup\",\n    content: html,\n    buttons: {\n      cancel: {label:\"Cancel\"},\n      ok: {label:`Delete ${total}`, callback: async () => {\n        if (items.length) await Item.deleteDocuments(items.map(i => i.id));\n        if (journals.length) await JournalEntry.deleteDocuments(journals.map(j => j.id));\n        ui.notifications.info(`Deleted ${items.length} Items and ${journals.length} Journals.`);\n      }}\n    },\n    default: \"cancel\"\n  }).render(true);\n})();", "ownership": {"default": 0}}
